<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script src="libsignal-protocol.js"></script>
<script src="InMemorySignalProtocolStore.js"></script>
<script src="helpers.js"></script>
<script src="base64-binary.js"></script>
<script>
    var KeyHelper = libsignal.KeyHelper;

    function generateIdentity(store) {
        return Promise.all([
            KeyHelper.generateIdentityKeyPair(),
            KeyHelper.generateRegistrationId(),
        ]).then(function(result) {
            store.put('identityKey', result[0]);
            store.put('registrationId', result[1]);
        });
    }

    function generatePreKeyBundle(store, preKeyId, signedPreKeyId) {
        return Promise.all([
            store.getIdentityKeyPair(),
            store.getLocalRegistrationId()
        ]).then(function(result) {
            var identity = result[0];
            var registrationId = result[1];

            return Promise.all([
                KeyHelper.generatePreKey(preKeyId),
                KeyHelper.generateSignedPreKey(identity, signedPreKeyId),
            ]).then(function(keys) {
                var preKey = keys[0];
                var signedPreKey = keys[1];

                store.storePreKey(preKeyId, preKey.keyPair);
                store.storeSignedPreKey(signedPreKeyId, signedPreKey.keyPair);

                return {
                    identityKey: identity.pubKey,
                    registrationId : registrationId,
                    preKey:  {
                        keyId     : preKeyId,
                        publicKey : preKey.keyPair.pubKey
                    },
                    signedPreKey: {
                        keyId     : signedPreKeyId,
                        publicKey : signedPreKey.keyPair.pubKey,
                        signature : signedPreKey.signature
                    }
                };
            });
        });
    }

    var ALICE_ADDRESS = new libsignal.SignalProtocolAddress("xxxxxxxxx", 1);
    var BOB_ADDRESS   = new libsignal.SignalProtocolAddress("yyyyyyyyyyyyy", 1);

    var aliceStore = new SignalProtocolStore();

    var bobStore = new SignalProtocolStore();
    var bobPreKeyId = 1337;
    var bobSignedKeyId = 1;

    Promise.all([
        generateIdentity(aliceStore),
        generateIdentity(bobStore)
    ]).then(function() {
        return generatePreKeyBundle(bobStore, bobPreKeyId, bobSignedKeyId);
    }).then(function(preKeyBundle) {
        //

        let test = {
            identityKey: preKeyBundle['identityKey'],
            registrationId : preKeyBundle['registrationId'],
            preKey:  {
                keyId     : preKeyBundle['preKey']['keyId'],
                publicKey : preKeyBundle['preKey']['publicKey']
            },
            signedPreKey: {
                keyId     : preKeyBundle['signedPreKey']['keyId'],
                publicKey : preKeyBundle['signedPreKey']['publicKey'],
                signature : preKeyBundle['signedPreKey']['signature']
            }
        };

        console.log(preKeyBundle['identityKey']);

        let temp = uint8ToBase64(preKeyBundle['identityKey']);
        console.log(temp);
        /*
        decode_bundle(temp, function(result) {
            var builder = new libsignal.SessionBuilder(aliceStore, BOB_ADDRESS);

            builder.processPreKey(result).then(function() {
                var originalMessage = util.toArrayBuffer("my message ......");
                var aliceSessionCipher = new libsignal.SessionCipher(aliceStore, BOB_ADDRESS);
                var bobSessionCipher = new libsignal.SessionCipher(bobStore, ALICE_ADDRESS);

                aliceSessionCipher.encrypt(originalMessage).then(function(ciphertext) {

                    console.log(ciphertext);

                    // check for ciphertext.type to be 3 which includes the PREKEY_BUNDLE
                    return bobSessionCipher.decryptPreKeyWhisperMessage(ciphertext.body, 'binary');

                }).then(function(plaintext) {

                    var enc = new TextDecoder("utf-8");

                    console.log(enc.decode(plaintext));

                });
            })


        });*/
        //

        /*
        var builder = new libsignal.SessionBuilder(aliceStore, BOB_ADDRESS);
        return builder.processPreKey(preKeyBundle).then(function() {

            var originalMessage = util.toArrayBuffer("my message ......");
            var aliceSessionCipher = new libsignal.SessionCipher(aliceStore, BOB_ADDRESS);
            var bobSessionCipher = new libsignal.SessionCipher(bobStore, ALICE_ADDRESS);

            aliceSessionCipher.encrypt(originalMessage).then(function(ciphertext) {

                console.log(ciphertext);

                // check for ciphertext.type to be 3 which includes the PREKEY_BUNDLE
                return bobSessionCipher.decryptPreKeyWhisperMessage(ciphertext.body, 'binary');

            }).then(function(plaintext) {

                var enc = new TextDecoder("utf-8");

                console.log(enc.decode(plaintext));

            });

            bobSessionCipher.encrypt(originalMessage).then(function(ciphertext) {

                return aliceSessionCipher.decryptWhisperMessage(ciphertext.body, 'binary');

            }).then(function(plaintext) {

                assertEqualArrayBuffers(plaintext, originalMessage);

            });

        });*/
    });

    function uint8ToBase64(buffer) {
        var binary = '';
        var len = buffer.byteLength;
        for (var i = 0; i < len; i++) {
            binary += String.fromCharCode(buffer[i]);
        }
        return window.btoa( binary );
    }



    /* {
        identityKey: identity.pubKey,
        registrationId : registrationId,
        preKey:  {
            keyId     : preKeyId,
            publicKey : preKey.keyPair.pubKey
        },
        signedPreKey: {
            keyId     : signedPreKeyId,
            publicKey : signedPreKey.keyPair.pubKey,
            signature : signedPreKey.signature
        }
    };*/
</script>
</body>
</html>