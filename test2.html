<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script src="libsignal-protocol.js"></script>
<script src="InMemorySignalProtocolStore.js"></script>
<script src="helpers.js"></script>
<script src="base64-binary.js"></script>
<script>
    let KeyHelper = libsignal.KeyHelper;

    let generateIdentity = function(store) {
        return Promise.all([
            KeyHelper.generateIdentityKeyPair(),
            KeyHelper.generateRegistrationId(),
        ]).then(function(result) {
            store.put('identityKey', result[0]);
            store.put('registrationId', result[1]);
        });
    };

    let generatePreKey = function(store, preKeyIds) {
        let generatePreKeys = [];

        preKeyIds.forEach(function (preKeyId) {
            generatePreKeys.push(KeyHelper.generatePreKey(preKeyId));
        });

        return Promise.all(generatePreKeys).then(function(keys) {
            keys.forEach(function (key) {
                store.storePreKey(key.keyId, key.keyPair);
            });

            return keys;
        });
    };

    let generateSignedPreKey = function(store, signedPreKeyId) {
        return store.getIdentityKeyPair().then(function (identity) {
            return KeyHelper.generateSignedPreKey(identity, signedPreKeyId).then(function (signedPreKey) {
                store.storeSignedPreKey(signedPreKey.keyId, signedPreKey.keyPair);

                return signedPreKey;
            });
        });
    };

    let generatePreKeyBundle = function (store, preKey, signedPreKey) {
        return Promise.all([
            store.getIdentityKeyPair(),
            store.getLocalRegistrationId()
        ]).then(function(result) {
            let identity = result[0];
            let registrationId = result[1];

            return {
                identityKey: identity.pubKey,
                registrationId : registrationId,
                preKey:  {
                    keyId     : preKey.keyId,
                    publicKey : preKey.keyPair.pubKey
                },
                signedPreKey: {
                    keyId     : signedPreKey.keyId,
                    publicKey : signedPreKey.keyPair.pubKey,
                    signature : signedPreKey.signature
                }
            };
        });
    };

    let aliceAddress = new libsignal.SignalProtocolAddress(123, 1);
    let bobAddress   = new libsignal.SignalProtocolAddress(456, 1);

    let aliceStore = new SignalProtocolStore();
    let bobStore = new SignalProtocolStore();

    let aliceSessionCipher = new libsignal.SessionCipher(aliceStore, bobAddress);
    let bobSessionCipher = new libsignal.SessionCipher(bobStore, aliceAddress);

    let bobSignedKeyId = 1;
    let bobPreKeyIds = [1, 2, 3, 4, 5, 6, 7, 8, 9];

    Promise.all([
        generateIdentity(aliceStore),
        generateIdentity(bobStore)
    ]).then(function() {
        generateSignedPreKey(bobStore, bobSignedKeyId).then(function (signedPreKey) {
            generatePreKey(bobStore, bobPreKeyIds).then(function (preKeys) {
                generatePreKeyBundle(bobStore, preKeys[0], signedPreKey).then(function (preKeyBundle) {

                })
            })
        })
    });

/*
        preKeyBundle['identityKey'] = ab2str(preKeyBundle['identityKey']);
        preKeyBundle['preKey']['publicKey'] = ab2str(preKeyBundle['preKey']['publicKey']);
        preKeyBundle['signedPreKey']['publicKey'] = ab2str(preKeyBundle['signedPreKey']['publicKey']);
        preKeyBundle['signedPreKey']['signature'] = ab2str(preKeyBundle['signedPreKey']['signature']);

        var json = JSON.parse(JSON.stringify(preKeyBundle));

        json['identityKey'] = str2ab(json['identityKey']);
        json['preKey']['publicKey'] = str2ab(json['preKey']['publicKey']);
        json['signedPreKey']['publicKey'] = str2ab(json['signedPreKey']['publicKey']);
        json['signedPreKey']['signature'] = str2ab(json['signedPreKey']['signature']);

        var builder = new libsignial.SessionBuilder(aliceStore, BOB_ADDRESS);

        builder.processPreKey(json).then(function() {
            var originalMessage = util.toArrayBuffer("my message ......");


            aliceSessionCipher.encrypt(originalMessage).then(function(ciphertext) {

                console.log(ciphertext);

                // check for ciphertext.type to be 3 which includes the PREKEY_BUNDLE
                return bobSessionCipher.decryptPreKeyWhisperMessage(ciphertext.body, 'binary');

            }).then(function(plaintext) {

                var enc = new TextDecoder("utf-8");

                console.log(enc.decode(plaintext));

            });
        })

        /*
        var builder = new libsignal.SessionBuilder(aliceStore, BOB_ADDRESS);
        return builder.processPreKey(preKeyBundle).then(function() {

            var originalMessage = util.toArrayBuffer("my message ......");
            var aliceSessionCipher = new libsignal.SessionCipher(aliceStore, BOB_ADDRESS);
            var bobSessionCipher = new libsignal.SessionCipher(bobStore, ALICE_ADDRESS);

            aliceSessionCipher.encrypt(originalMessage).then(function(ciphertext) {

                console.log(ciphertext);

                // check for ciphertext.type to be 3 which includes the PREKEY_BUNDLE
                return bobSessionCipher.decryptPreKeyWhisperMessage(ciphertext.body, 'binary');

            }).then(function(plaintext) {

                var enc = new TextDecoder("utf-8");

                console.log(enc.decode(plaintext));

            });

            bobSessionCipher.encrypt(originalMessage).then(function(ciphertext) {

                return aliceSessionCipher.decryptWhisperMessage(ciphertext.body, 'binary');

            }).then(function(plaintext) {

                assertEqualArrayBuffers(plaintext, originalMessage);

            });

        })
    });
*/
/*

    function ab2str(buf) {
        return String.fromCharCode.apply(null, new Uint8Array(buf));
    }

    function str2ab(str) {
        var buf = new ArrayBuffer(str.length); // 2 bytes for each char
        var bufView = new Uint8Array(buf);
        for (var i=0, strLen=str.length; i<strLen; i++) {
            bufView[i] = str.charCodeAt(i);
        }
        return buf;
    }
    */
</script>
</body>
</html>